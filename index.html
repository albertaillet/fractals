<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mandelbrot Fractal</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: monospace;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #0f0;
        font-size: 12px;
        text-shadow: 0 0 5px #0f0;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="info">
      <div>Scroll: Zoom | Drag: Pan | R: Reset</div>
      <div id="coords"></div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl2");
      const coordsDiv = document.getElementById("coords");

      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Shaders
      const vertexShaderSource = `#version 300 es
        in vec4 position;
        void main() {
          gl_Position = position;
        }
      `;

      const fragmentShaderSource = `#version 300 es
        precision highp float;
        uniform vec2 center;
        uniform float zoom;
        uniform vec2 resolution;
        out vec4 outColor;

        int mandelbrot(vec2 c) {
          vec2 z = vec2(0.0);
          int maxIter = 256;
          for (int i = 0; i < maxIter; i++) {
            float zx2 = z.x * z.x;
            float zy2 = z.y * z.y;
            if (zx2 + zy2 > 4.0) return i;
            z = vec2(zx2 - zy2 + c.x, 2.0 * z.x * z.y + c.y);
          }
          return 256;
        }

        void main() {
          vec2 uv = gl_FragCoord.xy / resolution;
          uv = uv * 2.0 - 1.0;
          uv.x *= resolution.x / resolution.y;
          uv *= zoom;
          uv += center;

          int iter = mandelbrot(uv);
          float col = float(iter) / 256.0;
          
          outColor = vec4(
            sin(col * 3.14159) * 0.5 + 0.5,
            sin(col * 3.14159 + 2.0) * 0.5 + 0.5,
            sin(col * 3.14159 + 4.0) * 0.5 + 0.5,
            1.0
          );
        }
      `;

      // Compile shader
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      // Create program
      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      // Quad vertices
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1, 1, -1, -1, 1, 1, 1
      ]), gl.STATIC_DRAW);

      const positionLoc = gl.getAttribLocation(program, "position");
      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

      // Uniforms
      const centerLoc = gl.getUniformLocation(program, "center");
      const zoomLoc = gl.getUniformLocation(program, "zoom");
      const resolutionLoc = gl.getUniformLocation(program, "resolution");

      // State
      let center = [-0.7, 0];
      let zoom = 3.5;

      // Input handling
      let isDragging = false;
      let lastX = 0, lastY = 0;

      canvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          const aspect = canvas.width / canvas.height;
          center[0] -= (dx / canvas.width) * zoom * aspect;
          center[1] += (dy / canvas.height) * zoom;
          lastX = e.clientX;
          lastY = e.clientY;
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        
        // Convert mouse position to world coordinates
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const uv = [x / canvas.width * 2 - 1, 1 - y / canvas.height * 2];
        const aspect = canvas.width / canvas.height;
        uv[0] *= aspect;
        
        const worldX = center[0] + uv[0] * zoom;
        const worldY = center[1] + uv[1] * zoom;
        
        // Zoom and keep cursor position fixed
        zoom *= zoomFactor;
        center[0] = worldX - uv[0] * zoom;
        center[1] = worldY - uv[1] * zoom;
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === 'r' || e.key === 'R') {
          center = [-0.7, 0];
          zoom = 3.5;
        }
      });

      // Render loop
      function render() {
        gl.uniform2f(centerLoc, center[0], center[1]);
        gl.uniform1f(zoomLoc, zoom);
        gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        coordsDiv.textContent = `Center: (${center[0].toFixed(4)}, ${center[1].toFixed(4)}) | Zoom: ${zoom.toFixed(4)}`;
        requestAnimationFrame(render);
      }

      render();
    </script>
  </body>
</html>
