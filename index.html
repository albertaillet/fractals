<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mandelbrot Fractal</title>
    <style>
      body { margin: 0; font-family: monospace; }
      #controls { position: absolute; top: 10px; background-color: white; }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="controls">
      <div>Scroll: Zoom | Drag: Pan | R: Reset</div>
      <div id="coords"></div>
      <div>Custom Fractal Formula (use z, c, z.x, z.y, c.x, c.y):</div>
      <div>
        Real part: <input type="text" id="realInput" value="z.x * z.x - z.y * z.y + c.x" />
      </div>
      <div>
        Imaginary part: <input type="text" id="imagInput" value="2.0 * z.x * z.y + c.y" />
      </div>
      <button id="applyBtn">Apply Formula</button>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl2");
      const coordsDiv = document.getElementById("coords");

      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Shaders
      const vertexShaderSource = `#version 300 es 
        in vec4 position; 
        void main() { gl_Position = position; }`;

      const fragmentShaderSource = `#version 300 es
        precision highp float;
        uniform vec2 center;
        uniform float zoom;
        uniform vec2 resolution;
        out vec4 outColor;

        void main() {
          vec2 uv = gl_FragCoord.xy / resolution;
          uv = uv * 2.0 - 1.0;
          uv.x *= resolution.x / resolution.y;
          uv *= zoom;
          uv += center;

          vec2 z = vec2(0.0);
          vec2 c = uv;
          int iter = 0;
          for (int i = 0; i < 256; i++) {
            float zx2 = z.x * z.x;
            float zy2 = z.y * z.y;
            if (zx2 + zy2 > 4.0) break;
            float real = REAL_FORMULA;
            float imag = IMAG_FORMULA;
            z = vec2(real, imag);
            iter = i;
          }
          
          float col = float(iter) / 256.0;
          outColor = vec4(0.0, 0.0, col, 1.0);
        }
      `;

      function createProgram(realFormula, imagFormula) {
        const compile = (src, type) => {
          const s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          return gl.getShaderParameter(s, gl.COMPILE_STATUS) ? s : null;
        };
        const prog = gl.createProgram();
        gl.attachShader(prog, compile(vertexShaderSource, gl.VERTEX_SHADER));
        gl.attachShader(prog, compile(fragmentShaderSource.replace("REAL_FORMULA", realFormula).replace("IMAG_FORMULA", imagFormula), gl.FRAGMENT_SHADER));
        gl.linkProgram(prog);
        return gl.getProgramParameter(prog, gl.LINK_STATUS) ? prog : null;
      }

      function setupAttributes() {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
        const loc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, 0, 0, 0);
      }

      let program = createProgram("z.x*z.x - z.y*z.y + c.x", "2.0*z.x*z.y + c.y");
      gl.useProgram(program);
      setupAttributes();
      let centerLoc = gl.getUniformLocation(program, "center");
      let zoomLoc = gl.getUniformLocation(program, "zoom");
      let resolutionLoc = gl.getUniformLocation(program, "resolution");
      let center = [-0.7, 0], zoom = 3.5, isDragging = false, lastX = 0, lastY = 0;

      canvas.addEventListener("mousedown", e => (isDragging=true, lastX=e.clientX, lastY=e.clientY));
      canvas.addEventListener("mousemove", e => {
        if(!isDragging) return;
        const a = canvas.width/canvas.height;
        center[0] -= ((e.clientX-lastX)/canvas.width)*zoom*a;
        center[1] += ((e.clientY-lastY)/canvas.height)*zoom;
        lastX=e.clientX; lastY=e.clientY;
      });
      canvas.addEventListener("mouseup", () => isDragging=false);
      canvas.addEventListener("wheel", e => {
        e.preventDefault();
        const z = e.deltaY > 0 ? 1.1 : 0.9;
        const r = canvas.getBoundingClientRect();
        const u = [(e.clientX-r.left)/canvas.width*2-1, 1-(e.clientY-r.top)/canvas.height*2];
        u[0] *= canvas.width/canvas.height;
        const wx = center[0]+u[0]*zoom, wy = center[1]+u[1]*zoom;
        zoom *= z;
        center[0] = wx-u[0]*zoom;
        center[1] = wy-u[1]*zoom;
      });
      document.addEventListener("keydown", e => {
        if(e.key==='r'||e.key==='R') {center=[-0.7,0]; zoom=3.5;}
      });
      document.getElementById("applyBtn").addEventListener("click", () => {
        const p = createProgram(document.getElementById("realInput").value, document.getElementById("imagInput").value);
        if(p) {
          program=p; 
          gl.useProgram(program); 
          setupAttributes();
          centerLoc = gl.getUniformLocation(program,"center"); 
          zoomLoc = gl.getUniformLocation(program,"zoom"); 
          resolutionLoc = gl.getUniformLocation(program,"resolution");}
      });

      // Render loop
      function render() {
        gl.uniform2f(centerLoc, center[0], center[1]);
        gl.uniform1f(zoomLoc, zoom);
        gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        coordsDiv.textContent = `Center: (${center[0].toFixed(4)}, ${center[1].toFixed(4)}) | Zoom: ${zoom.toFixed(4)}`;
        requestAnimationFrame(render);
      }

      render();
    </script>
  </body>
</html>
