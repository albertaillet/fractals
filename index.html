<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mandelbrot Fractal</title>
    <style>
      body { margin: 0; font-family: monospace; }
      #info, #controls { position: absolute; left: 10px; }
      #info { top: 10px; }
      #controls { bottom: 10px}
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="info">
      <div>Scroll: Zoom | Drag: Pan | R: Reset</div>
      <div id="coords"></div>
    </div>
    <div id="controls">
      <div>Custom Fractal Formula (use z, c, z.x, z.y, c.x, c.y):</div>
      <div>
        Real part: <input type="text" id="realInput" value="z.x * z.x - z.y * z.y + c.x" />
      </div>
      <div>
        Imaginary part: <input type="text" id="imagInput" value="2.0 * z.x * z.y + c.y" />
      </div>
      <button id="applyBtn">Apply Formula</button>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl2");
      const coordsDiv = document.getElementById("coords");

      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Shaders
      const vertexShaderSource = `#version 300 es
        in vec4 position;
        void main() {
          gl_Position = position;
        }
      `;

      const fragmentShaderSource = `#version 300 es
        precision highp float;
        uniform vec2 center;
        uniform float zoom;
        uniform vec2 resolution;
        out vec4 outColor;

        void main() {
          vec2 uv = gl_FragCoord.xy / resolution;
          uv = uv * 2.0 - 1.0;
          uv.x *= resolution.x / resolution.y;
          uv *= zoom;
          uv += center;

          vec2 z = vec2(0.0);
          vec2 c = uv;
          int iter = 0;
          for (int i = 0; i < 256; i++) {
            float zx2 = z.x * z.x;
            float zy2 = z.y * z.y;
            if (zx2 + zy2 > 4.0) break;
            float real = REAL_FORMULA;
            float imag = IMAG_FORMULA;
            z = vec2(real, imag);
            iter = i;
          }
          
          float col = float(iter) / 256.0;
          outColor = vec4(
            sin(col * 3.14159) * 0.5 + 0.5,
            sin(col * 3.14159 + 2.0) * 0.5 + 0.5,
            sin(col * 3.14159 + 4.0) * 0.5 + 0.5,
            1.0
          );
        }
      `;

      // Compile shader
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }

      // Create program with custom formulas
      function createProgram(realFormula, imagFormula) {
        const shader = fragmentShaderSource
          .replace("REAL_FORMULA", realFormula)
          .replace("IMAG_FORMULA", imagFormula);
        
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(shader, gl.FRAGMENT_SHADER);
        
        if (!vertexShader || !fragmentShader) return null;
        
        const prog = gl.createProgram();
        gl.attachShader(prog, vertexShader);
        gl.attachShader(prog, fragmentShader);
        gl.linkProgram(prog);
        
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(prog));
          return null;
        }
        
        return prog;
      }

      function setupAttributes() {
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          -1, -1, 1, -1, -1, 1, 1, 1
        ]), gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
      }

      // Initial program
      let program = createProgram(
        "z.x * z.x - z.y * z.y + c.x",
        "2.0 * z.x * z.y + c.y"
      );
      gl.useProgram(program);
      setupAttributes();
      const centerLoc = gl.getUniformLocation(program, "center");
      const zoomLoc = gl.getUniformLocation(program, "zoom");
      const resolutionLoc = gl.getUniformLocation(program, "resolution");

      // State
      let center = [-0.7, 0];
      let zoom = 3.5;

      // Input handling
      let isDragging = false, lastX = 0, lastY = 0;

      canvas.addEventListener("mousedown", e => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      canvas.addEventListener("mousemove", e => {
        if (!isDragging) return;
        const aspect = canvas.width / canvas.height;
        center[0] -= ((e.clientX - lastX) / canvas.width) * zoom * aspect;
        center[1] += ((e.clientY - lastY) / canvas.height) * zoom;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      canvas.addEventListener("mouseup", () => isDragging = false);

      canvas.addEventListener("wheel", e => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        const rect = canvas.getBoundingClientRect();
        const uv = [
          (e.clientX - rect.left) / canvas.width * 2 - 1,
          1 - (e.clientY - rect.top) / canvas.height * 2
        ];
        const aspect = canvas.width / canvas.height;
        uv[0] *= aspect;
        const worldX = center[0] + uv[0] * zoom;
        const worldY = center[1] + uv[1] * zoom;
        zoom *= zoomFactor;
        center[0] = worldX - uv[0] * zoom;
        center[1] = worldY - uv[1] * zoom;
      });

      document.addEventListener("keydown", e => {
        if ((e.key === 'r' || e.key === 'R')) {
          center = [-0.7, 0];
          zoom = 3.5;
        }
      });

      document.getElementById("applyBtn").addEventListener("click", () => {
        const real = document.getElementById("realInput").value;
        const imag = document.getElementById("imagInput").value;
        const newProgram = createProgram(real, imag);
        if (newProgram) {
          program = newProgram;
          gl.useProgram(program);
          setupAttributes();
        } else {
          alert("Error compiling formula. Check console.");
        }
      });

      function setupAttributes() {
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          -1, -1, 1, -1, -1, 1, 1, 1
        ]), gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
      }

      // Render loop
      function render() {
        gl.uniform2f(centerLoc, center[0], center[1]);
        gl.uniform1f(zoomLoc, zoom);
        gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        coordsDiv.textContent = `Center: (${center[0].toFixed(4)}, ${center[1].toFixed(4)}) | Zoom: ${zoom.toFixed(4)}`;
        requestAnimationFrame(render);
      }

      render();
    </script>
  </body>
</html>
